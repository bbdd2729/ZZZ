# 现有架构改造实施指南

## 概述
本指南提供基于现有项目架构的渐进式改造方案，避免大规模重构带来的风险，同时提升代码质量和可维护性。

## 现有架构分析

### 当前架构优势
1. **状态机基础良好**：已有完整的状态机框架
2. **事件系统成熟**：EventBus和GameEvents设计合理
3. **输入系统分离**：InputSystem独立管理输入
4. **DI容器初步集成**：VContainer已配置基础服务

### 需要改进的关键点
1. **PlayerManager单例模式**：不利于测试和扩展
2. **状态机耦合度过高**：StateMachine与PlayerController紧密耦合
3. **角色切换逻辑复杂**：切换状态管理分散
4. **缺乏接口抽象**：具体实现依赖过多

## 渐进式改造策略

### 第一阶段：接口抽象化（低风险）

#### 1.1 创建核心接口
在现有代码基础上，首先创建接口层，不修改现有实现：

```csharp
// 新文件：Assets/Scripts/RunTime/Controller/Manager/PlayerManager/IPlayerManager.cs
public interface IPlayerManager
{
    PlayerController CurrentPlayer { get; }
    IReadOnlyList<PlayerController> PlayerControllers { get; }
    
    void Initialize();
    void SwitchNextPlayer();
    void SwitchToPlayer(int playerIndex);
    void AddPlayer(PlayerController playerController);
    
    bool CanSwitchPlayer();
    event Action<PlayerController> OnPlayerSwitched;
}

// 新文件：Assets/Scripts/RunTime/Controller/Player/PlayerController/FSM/IStateMachine.cs
public interface IStateMachine
{
    BaseState CurrentState { get; }
    bool StateLocked { get; }
    
    void RegisterState<T>(T state) where T : IState;
    void ChangeState<T>() where T : IState;
    void Update();
    
    void Lock();
    void Unlock();
}
```

#### 1.2 修改现有类实现接口
**修改现有文件：Assets/Scripts/RunTime/Controller/Manager/PlayerManager/PlayerManager.cs**

```csharp
// 在类声明中添加接口实现
public class PlayerManager : SingletonBase<PlayerManager>, IPlayerManager
{
    // 添加事件支持
    public event Action<PlayerController> OnPlayerSwitched;
    
    // 修改SwitchNextPlayer方法，添加事件触发
    public void SwitchNextPlayer()
    {
        // 现有逻辑保持不变...
        
        // 在切换完成后添加事件触发
        OnPlayerSwitched?.Invoke(CurrentPlayer);
    }
    
    // 添加CanSwitchPlayer方法
    public bool CanSwitchPlayer()
    {
        return CurrentPlayer != null && !CurrentPlayer._stateMachine.StateLocked;
    }
}
```

**修改现有文件：Assets/Scripts/RunTime/Controller/Player/PlayerController/FSM/StateMachine.cs**

```csharp
// 让StateMachine实现IStateMachine接口
public class StateMachine : IStateMachine
{
    // 现有代码保持不变，确保实现接口的所有成员
    public BaseState CurrentState 
    { 
        get => _currentState as BaseState; 
        private set => _currentState = value; 
    }
}
```

### 第二阶段：依赖注入改造（中等风险）

#### 2.1 创建可注入的服务
**新文件：Assets/Scripts/RunTime/Controller/Manager/PlayerManager/PlayerManagerService.cs**

```csharp
using VContainer;

// 可注入的角色管理服务
public class PlayerManagerService : IPlayerManager, IDisposable
{
    private readonly PlayerManager _playerManager;
    
    [Inject]
    public PlayerManagerService(PlayerManager playerManager)
    {
        _playerManager = playerManager;
    }
    
    public PlayerController CurrentPlayer => _playerManager.CurrentPlayer;
    public IReadOnlyList<PlayerController> PlayerControllers => _playerManager.PlayerControllers;
    
    public void Initialize() => _playerManager.Init();
    public void SwitchNextPlayer() => _playerManager.SwitchNextPlayer();
    public void SwitchToPlayer(int playerIndex) => _playerManager.SwitchToPlayer(playerIndex);
    public void AddPlayer(PlayerController playerController) => _playerManager.AddPlayer(playerController);
    
    public bool CanSwitchPlayer() => _playerManager.CanSwitchPlayer();
    
    public event Action<PlayerController> OnPlayerSwitched
    {
        add => _playerManager.OnPlayerSwitched += value;
        remove => _playerManager.OnPlayerSwitched -= value;
    }
    
    public void Dispose()
    {
        // 清理事件订阅
        _playerManager.OnPlayerSwitched = null;
    }
}
```

#### 2.2 更新DI配置
**修改现有文件：Assets/Scripts/RunTime/Controller/DI/PersonalLifeTimeScope.cs**

```csharp
protected override void Configure(IContainerBuilder builder)
{
    // 现有配置保持不变...
    
    // 添加新的服务注册
    builder.Register<PlayerManagerService>(Lifetime.Singleton).As<IPlayerManager>();
    builder.Register<StateMachineFactory>(Lifetime.Singleton).As<IStateMachineFactory>();
    
    // 保持向后兼容
    builder.RegisterBuildCallback(container =>
    {
        // 确保单例实例可用
        var playerManager = container.Resolve<IPlayerManager>();
        PlayerManager.Instance.OnPlayerSwitched += (player) =>
        {
            // 保持现有事件系统兼容
        };
    });
}
```

### 第三阶段：状态机解耦（中等风险）

#### 3.1 创建状态机工厂
**新文件：Assets/Scripts/RunTime/Controller/Player/PlayerController/FSM/StateMachineFactory.cs**

```csharp
using VContainer;

public class StateMachineFactory : IStateMachineFactory
{
    private readonly IObjectResolver _container;
    private readonly ILogger _logger;
    
    public StateMachineFactory(IObjectResolver container, ILogger logger)
    {
        _container = container;
        _logger = logger;
    }
    
    public IStateMachine CreateStateMachine(PlayerController playerController)
    {
        var stateMachine = _container.Resolve<IStateMachine>();
        
        // 注册所有状态
        RegisterPlayerStates(stateMachine, playerController);
        
        return stateMachine;
    }
    
    private void RegisterPlayerStates(IStateMachine stateMachine, PlayerController playerController)
    {
        // 使用容器创建状态实例，支持依赖注入
        var idleState = _container.Resolve<IdleState>();
        var walkState = _container.Resolve<WalkState>();
        var runState = _container.Resolve<RunState>();
        var attackState = _container.Resolve<AttackState>();
        var switchInState = _container.Resolve<SwitchInState>();
        var switchOutState = _container.Resolve<SwitchOutState>();
        
        // 注册状态
        stateMachine.RegisterState(idleState);
        stateMachine.RegisterState(walkState);
        stateMachine.RegisterState(runState);
        stateMachine.RegisterState(attackState);
        stateMachine.RegisterState(switchInState);
        stateMachine.RegisterState(switchOutState);
        
        // 设置初始状态
        stateMachine.ChangeState<IdleState>();
    }
}
```

#### 3.2 修改PlayerController使用工厂
**修改现有文件：Assets/Scripts/RunTime/Controller/Player/PlayerController/PlayerController.cs**

```csharp
using VContainer;

public class PlayerController : MonoBehaviour
{
    [Inject] private IStateMachineFactory _stateMachineFactory;
    
    private void Awake()
    {
        // 获取组件
        _animator = GetComponent<Animator>();
        _characterController = GetComponent<CharacterController>();
        
        // 使用工厂创建状态机
        if (_stateMachineFactory != null)
        {
            _stateMachine = _stateMachineFactory.CreateStateMachine(this);
        }
        else
        {
            // 回退到原有创建方式，保持兼容性
            CreateStateMachineManually();
        }
    }
    
    private void CreateStateMachineManually()
    {
        // 原有状态机创建逻辑
        _stateMachine = new StateMachine(this, _characterController, _animator);
        
        // 注册状态（保持原有逻辑）
        _stateMachine.RegisterState(new IdleState());
        _stateMachine.RegisterState(new WalkState());
        // ... 其他状态注册
    }
}
```

### 第四阶段：角色切换优化（高风险高回报）

#### 4.1 创建专用的切换状态管理器
**新文件：Assets/Scripts/RunTime/Controller/Player/PlayerController/PlayerSwitchManager.cs**

```csharp
using System.Collections;
using VContainer;

public class PlayerSwitchManager : IPlayerSwitchManager
{
    private readonly ICoroutineRunner _coroutineRunner;
    private readonly IEventBus _eventBus;
    private readonly ILogger _logger;
    
    private PlayerSwitchContext _currentSwitchContext;
    private bool _isSwitching = false;
    
    public PlayerSwitchManager(
        ICoroutineRunner coroutineRunner,
        IEventBus eventBus,
        ILogger logger)
    {
        _coroutineRunner = coroutineRunner;
        _eventBus = eventBus;
        _logger = logger;
    }
    
    public bool IsSwitching => _isSwitching;
    
    public void StartPlayerSwitch(PlayerController fromPlayer, PlayerController toPlayer)
    {
        if (_isSwitching) return;
        
        _currentSwitchContext = new PlayerSwitchContext
        {
            FromPlayer = fromPlayer,
            ToPlayer = toPlayer,
            StartTime = Time.time
        };
        
        _coroutineRunner.StartCoroutine(PerformPlayerSwitch());
    }
    
    private IEnumerator PerformPlayerSwitch()
    {
        _isSwitching = true;
        _logger.Log("Player switch started");
        
        // 阶段1：准备切换
        yield return PrepareSwitch();
        
        // 阶段2：执行切换出
        yield return SwitchOut();
        
        // 阶段3：执行切换入
        yield return SwitchIn();
        
        // 阶段4：完成切换
        yield return CompleteSwitch();
        
        _isSwitching = false;
        _logger.Log("Player switch completed");
        
        // 发布切换完成事件
        _eventBus.Publish(new PlayerSwitchCompletedEvent(
            _currentSwitchContext.FromPlayer,
            _currentSwitchContext.ToPlayer
        ));
    }
    
    private IEnumerator PrepareSwitch()
    {
        var fromPlayer = _currentSwitchContext.FromPlayer;
        
        // 锁定当前玩家的状态机
        fromPlayer._stateMachine.Lock();
        
        // 检查是否可以切换
        if (!fromPlayer._stateMachine.CanTransition())
        {
            _logger.LogWarning("Cannot switch player - current state locked");
            yield break;
        }
        
        yield return null;
    }
    
    private IEnumerator SwitchOut()
    {
        var fromPlayer = _currentSwitchContext.FromPlayer;
        
        // 切换到切换出状态
        fromPlayer._stateMachine.ChangeState<SwitchOutState>();
        
        // 等待切换出动画完成
        yield return WaitForSwitchAnimation("SwitchOut_Normal", fromPlayer);
        
        // 禁用当前玩家
        fromPlayer.SetInputActive(false);
        fromPlayer.enabled = false;
    }
    
    private IEnumerator SwitchIn()
    {
        var toPlayer = _currentSwitchContext.ToPlayer;
        
        // 激活目标玩家
        toPlayer.gameObject.SetActive(true);
        toPlayer.enabled = true;
        
        // 切换到切换入状态
        toPlayer._stateMachine.ChangeState<SwitchInState>();
        
        // 等待切换入动画完成
        yield return WaitForSwitchAnimation("SwitchIn_Normal", toPlayer);
    }
    
    private IEnumerator CompleteSwitch()
    {
        var toPlayer = _currentSwitchContext.ToPlayer;
        
        // 启用新玩家的输入
        toPlayer.SetInputActive(true);
        
        // 解锁状态机
        toPlayer._stateMachine.Unlock();
        
        // 隐藏旧玩家
        _currentSwitchContext.FromPlayer.gameObject.SetActive(false);
        
        yield return null;
    }
    
    private IEnumerator WaitForSwitchAnimation(string animationName, PlayerController player)
    {
        var animator = player.GetComponent<Animator>();
        var waitTime = 0f;
        var maxWaitTime = 2f; // 最大等待时间
        
        while (waitTime < maxWaitTime)
        {
            if (animator.GetCurrentAnimatorStateInfo(0).IsName(animationName) &&
                animator.GetCurrentAnimatorStateInfo(0).normalizedTime >= 0.9f)
            {
                yield break;
            }
            
            waitTime += Time.deltaTime;
            yield return null;
        }
        
        _logger.LogWarning($"Animation {animationName} did not complete in time");
    }
}
```

#### 4.2 修改PlayerManager使用新的切换管理器
**修改现有文件：Assets/Scripts/RunTime/Controller/Manager/PlayerManager/PlayerManager.cs**

```csharp
using VContainer;

public class PlayerManager : SingletonBase<PlayerManager>, IPlayerManager
{
    [Inject] private IPlayerSwitchManager _switchManager;
    
    public void SwitchNextPlayer()
    {
        if (!CanSwitchPlayer()) return;
        
        if (_switchManager != null && _switchManager.IsSwitching) return;
        
        var oldPlayer = CurrentPlayer;
        var newPlayerIndex = (_currentPlayerIndex + 1) % PlayerControllers.Count;
        var newPlayer = PlayerControllers[newPlayerIndex];
        
        if (_switchManager != null)
        {
            // 使用新的切换管理器
            _switchManager.StartPlayerSwitch(oldPlayer, newPlayer);
            _currentPlayerIndex = newPlayerIndex;
            CurrentPlayer = newPlayer;
        }
        else
        {
            // 回退到原有切换逻辑
            PerformLegacyPlayerSwitch(oldPlayer, newPlayer);
        }
        
        OnPlayerSwitched?.Invoke(CurrentPlayer);
    }
    
    private void PerformLegacyPlayerSwitch(PlayerController oldPlayer, PlayerController newPlayer)
    {
        // 原有切换逻辑
        if (oldPlayer != null)
        {
            oldPlayer.SetInputActive(false);
            oldPlayer.enabled = false;
            oldPlayer._stateMachine.ChangeState<SwitchOutState>();
        }
        
        newPlayer.gameObject.SetActive(true);
        newPlayer.enabled = true;
        newPlayer._stateMachine.ChangeState<SwitchInState>();
        
        var oldPlayerIndex = (_currentPlayerIndex - 1 + PlayerControllers.Count) % PlayerControllers.Count;
        PlayerControllers[oldPlayerIndex].gameObject.SetActive(false);
    }
}
```

## 性能优化建议

### 1. 对象池化
```csharp
// 在PlayerManager中添加对象池支持
private readonly Dictionary<string, Queue<GameObject>> _playerPools = new();

public GameObject GetPlayerFromPool(string playerId, Vector3 position, Quaternion rotation)
{
    if (_playerPools.TryGetValue(playerId, out var pool) && pool.Count > 0)
    {
        var obj = pool.Dequeue();
        obj.transform.SetPositionAndRotation(position, rotation);
        obj.SetActive(true);
        return obj;
    }
    return null;
}

public void ReturnPlayerToPool(string playerId, GameObject playerObject)
{
    playerObject.SetActive(false);
    
    if (!_playerPools.ContainsKey(playerId))
        _playerPools[playerId] = new Queue<GameObject>();
    
    _playerPools[playerId].Enqueue(playerObject);
}
```

### 2. 状态机性能优化
```csharp
// 在StateMachine中添加性能监控
private readonly Stopwatch _stateUpdateTimer = new();
private readonly Dictionary<Type, long> _stateUpdateTimes = new();

public void Update()
{
    if (_currentState == null) return;
    
    _stateUpdateTimer.Restart();
    _currentState.Update();
    _stateUpdateTimer.Stop();
    
    var stateType = _currentState.GetType();
    _stateUpdateTimes[stateType] = _stateUpdateTimer.ElapsedMilliseconds;
    
    // 记录性能数据
    if (_stateUpdateTimer.ElapsedMilliseconds > 16) // 超过1帧时间
    {
        Debug.LogWarning($"State {stateType.Name} took {_stateUpdateTimer.ElapsedMilliseconds}ms to update");
    }
}
```

## 测试策略

### 1. 单元测试
```csharp
[TestFixture]
public class PlayerManagerTests
{
    private IPlayerManager _playerManager;
    private Mock<IPlayerFactory> _mockPlayerFactory;
    private Mock<IEventBus> _mockEventBus;
    
    [SetUp]
    public void Setup()
    {
        _mockPlayerFactory = new Mock<IPlayerFactory>();
        _mockEventBus = new Mock<IEventBus>();
        
        _playerManager = new PlayerManager(
            _mockPlayerFactory.Object,
            _mockEventBus.Object
        );
    }
    
    [Test]
    public void SwitchToPlayer_ValidIndex_SwitchesSuccessfully()
    {
        // Arrange
        var mockPlayer1 = new Mock<IPlayer>();
        var mockPlayer2 = new Mock<IPlayer>();
        
        _playerManager.AddPlayer(mockPlayer1.Object);
        _playerManager.AddPlayer(mockPlayer2.Object);
        
        // Act
        _playerManager.SwitchToPlayer(1);
        
        // Assert
        Assert.AreEqual(mockPlayer2.Object, _playerManager.CurrentPlayer);
        mockPlayer1.Verify(p => p.Deactivate(), Times.Once);
        mockPlayer2.Verify(p => p.Activate(), Times.Once);
    }
}
```

### 2. 集成测试
```csharp
[TestFixture]
public class PlayerSwitchIntegrationTests
{
    [UnityTest]
    public IEnumerator PlayerSwitch_CompleteSwitchSequence_Success()
    {
        // Arrange
        var playerManager = Object.FindObjectOfType<PlayerManager>();
        var initialPlayer = playerManager.CurrentPlayer;
        
        // Act
        playerManager.SwitchNextPlayer();
        
        // Wait for switch to complete
        yield return new WaitForSeconds(2f);
        
        // Assert
        Assert.AreNotEqual(initialPlayer, playerManager.CurrentPlayer);
        Assert.IsFalse(initialPlayer.gameObject.activeInHierarchy);
        Assert.IsTrue(playerManager.CurrentPlayer.gameObject.activeInHierarchy);
    }
}
```

## 部署和回滚策略

### 1. 分阶段部署
1. **开发环境**：完整新架构测试
2. **测试环境**：A/B测试，对比性能
3. **预生产环境**：小规模用户测试
4. **生产环境**：逐步灰度发布

### 2. 回滚机制
```csharp
// 在PlayerManager中添加功能开关
public class PlayerManager : SingletonBase<PlayerManager>, IPlayerManager
{
    [SerializeField] private bool _useNewSwitchSystem = true;
    
    public void SwitchNextPlayer()
    {
        if (_useNewSwitchSystem)
        {
            // 使用新系统
            PerformNewPlayerSwitch();
        }
        else
        {
            // 回退到旧系统
            PerformLegacyPlayerSwitch();
        }
    }
}
```

## 总结

这个渐进式改造方案能够在保持现有功能稳定的前提下，逐步引入新的架构设计。通过接口抽象、依赖注入、专用服务等方式，显著提升代码的可维护性、可测试性和扩展性。同时提供了完整的回滚机制和性能优化建议，确保改造过程的安全性和可靠性。