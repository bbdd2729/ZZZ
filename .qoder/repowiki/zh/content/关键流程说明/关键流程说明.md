# 关键流程说明

<cite>
**本文档引用的文件**   
- [PlayerController.cs](file://Assets/Scripts/Controller/PlayerController.cs)
- [StateMachine.cs](file://Assets/Scripts/Controller/FSM/StateMachine.cs)
- [BaseState.cs](file://Assets/Scripts/Controller/FSM/BaseState.cs)
- [IState.cs](file://Assets/Scripts/Controller/FSM/IState.cs)
- [PlayerManager.cs](file://Assets/Scripts/Manager/PlayerManager/PlayerManager.cs)
- [SwitchOutState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchOutState.cs)
- [SwitchInState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchInState.cs)
- [AttackState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackState.cs)
- [AttackEndState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackEndState.cs)
- [InputSystem.cs](file://Assets/Scripts/Manager/InputSystem/InputSystem.cs)
- [InputSystem_Actions.cs](file://Assets/InputSystem_Actions.cs)
- [GameMain.cs](file://Assets/Scripts/Manager/GameMain.cs)
</cite>

## 目录
1. [角色切换流程](#角色切换流程)
2. [攻击流程](#攻击流程)
3. [状态切换通用流程](#状态切换通用流程)

## 角色切换流程

角色切换流程从玩家按下Space键开始，通过输入系统触发事件，由PlayerManager处理角色切换逻辑，状态机执行SwitchOutState和SwitchInState状态。整个流程确保了角色切换的平滑过渡和状态的正确管理。

```mermaid
sequenceDiagram
participant Player as "玩家"
participant InputSystem as "InputSystem"
participant PlayerManager as "PlayerManager"
participant StateMachine as "StateMachine"
participant SwitchOutState as "SwitchOutState"
participant SwitchInState as "SwitchInState"
Player->>InputSystem : 按下Space键
InputSystem->>PlayerManager : 触发SwitchCharacterEvent
PlayerManager->>PlayerManager : SwitchNextPlayer()
alt 当前角色存在
PlayerManager->>StateMachine : ChangeState<SwitchOutState>
StateMachine->>SwitchOutState : OnEnter()
SwitchOutState->>SwitchOutState : 播放Switch_Out动画
SwitchOutState->>PlayerController : 隐藏当前角色模型
SwitchOutState->>StateMachine : 监听动画结束
end
PlayerManager->>PlayerManager : 更新_currentPlayerIndex
PlayerManager->>PlayerManager : 设置CurrentPlayer
PlayerManager->>PlayerController : 显示新角色模型
PlayerManager->>StateMachine : ChangeState<SwitchInState>
StateMachine->>SwitchInState : OnEnter()
SwitchInState->>SwitchInState : 播放Switch_In动画
SwitchInState->>StateMachine : 监听动画结束
SwitchInState->>StateMachine : ChangeState<IdleState>
SwitchOutState->>StateMachine : 动画结束
SwitchOutState->>StateMachine : ChangeState<IdleState>
Note over SwitchOutState,SwitchInState : 角色切换动画播放期间，状态机被锁定
```

**Diagram sources**
- [InputSystem.cs](file://Assets/Scripts/Manager/InputSystem/InputSystem.cs#L24)
- [PlayerManager.cs](file://Assets/Scripts/Manager/PlayerManager/PlayerManager.cs#L26)
- [SwitchOutState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchOutState.cs#L5)
- [SwitchInState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchInState.cs#L5)

**Section sources**
- [InputSystem.cs](file://Assets/Scripts/Manager/InputSystem/InputSystem.cs#L24-L70)
- [PlayerManager.cs](file://Assets/Scripts/Manager/PlayerManager/PlayerManager.cs#L26-L50)
- [SwitchOutState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchOutState.cs#L5-L32)
- [SwitchInState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/SwitchInState.cs#L5-L33)

## 攻击流程

攻击流程从玩家按下攻击键开始，状态机切换到AttackState，处理连击逻辑，并在攻击结束后进入AttackEndState处理后摇。该流程实现了流畅的连击系统和攻击后摇机制。

```mermaid
sequenceDiagram
participant Player as "玩家"
participant InputSystem as "InputSystem"
participant StateMachine as "StateMachine"
participant AttackState as "AttackState"
participant AttackEndState as "AttackEndState"
Player->>InputSystem : 按下攻击键
InputSystem->>BaseState : 触发OnAttack事件
BaseState->>StateMachine : ChangeState<AttackState>
StateMachine->>AttackState : OnEnter()
AttackState->>AttackState : 播放Attack_Normal_X动画
loop 每帧更新
AttackState->>AttackState : Update()
alt 动画播放时间 >= 0.5f 且再次按下攻击键
AttackState->>AttackState : enterNextAttack = true
end
alt 动画结束
alt enterNextAttack为true
AttackState->>AttackState : currentNormalAttackIndex++
AttackState->>StateMachine : ChangeState<AttackState>
StateMachine->>AttackState : 重新开始攻击
else
AttackState->>StateMachine : ChangeState<AttackEndState>
StateMachine->>AttackEndState : OnEnter()
AttackEndState->>AttackEndState : 播放Attack_Normal_X_End动画
end
end
end
loop AttackEndState更新
AttackEndState->>AttackEndState : Update()
alt 按下攻击键
AttackEndState->>AttackState : currentNormalAttackIndex++
AttackEndState->>StateMachine : ChangeState<AttackState>
end
end
Note over AttackState,AttackEndState : 连击逻辑通过currentNormalAttackIndex控制攻击段数
```

**Diagram sources**
- [InputSystem.cs](file://Assets/Scripts/Manager/InputSystem/InputSystem.cs#L40)
- [BaseState.cs](file://Assets/Scripts/Controller/FSM/BaseState.cs#L60)
- [AttackState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackState.cs#L5)
- [AttackEndState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackEndState.cs#L5)

**Section sources**
- [AttackState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackState.cs#L5-L60)
- [AttackEndState.cs](file://Assets/Scripts/Controller/FSM/CharacterState/AttackEndState.cs#L5-L43)
- [BaseState.cs](file://Assets/Scripts/Controller/FSM/BaseState.cs#L60-L65)

## 状态切换通用流程

状态切换的通用流程包括输入检测、状态机验证、当前状态退出和新状态进入四个阶段。这个流程确保了状态切换的安全性和一致性。

```mermaid
flowchart TD
Start([输入事件触发]) --> InputDetection["输入检测"]
InputDetection --> StateMachineValidation["状态机验证<br/>StateLocked和IsEnabled检查"]
StateMachineValidation --> CurrentStateExit["当前状态退出<br/>_currentState?.OnExit()"]
CurrentStateExit --> NewStateCheck["新状态存在性检查<br/>_states.TryGetValue()"]
NewStateCheck --> NewStateEnter["新状态进入<br/>_currentState = newState<br/>_currentState.OnEnter()"]
NewStateEnter --> End([状态切换完成])
style Start fill:#f9f,stroke:#333,stroke-width:2px
style End fill:#bbf,stroke:#333,stroke-width:2px
```

```mermaid
sequenceDiagram
participant Input as "输入系统"
participant StateMachine as "StateMachine"
participant CurrentState as "当前状态"
participant NewState as "新状态"
Input->>StateMachine : ChangeState<T>()
StateMachine->>StateMachine : 验证StateLocked和IsEnabled
alt 状态机未锁定且已启用
StateMachine->>CurrentState : OnExit()
CurrentState-->>StateMachine : 退出完成
StateMachine->>StateMachine : 查找新状态
alt 新状态存在
StateMachine->>NewState : OnEnter()
NewState-->>StateMachine : 进入完成
StateMachine-->>Input : 状态切换成功
else
StateMachine-->>Input : 状态未注册错误
end
else
StateMachine-->>Input : 状态机锁定或禁用
end
Note over StateMachine : 状态切换是原子操作，确保状态一致性
```

**Diagram sources**
- [StateMachine.cs](file://Assets/Scripts/Controller/FSM/StateMachine.cs#L40)
- [BaseState.cs](file://Assets/Scripts/Controller/FSM/BaseState.cs#L10)
- [IState.cs](file://Assets/Scripts/Controller/FSM/IState.cs#L2)

**Section sources**
- [StateMachine.cs](file://Assets/Scripts/Controller/FSM/StateMachine.cs#L40-L65)
- [BaseState.cs](file://Assets/Scripts/Controller/FSM/BaseState.cs#L10-L84)
- [IState.cs](file://Assets/Scripts/Controller/FSM/IState.cs#L2-L5)